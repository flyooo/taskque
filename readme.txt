在任务队列中，任务必需保证唯一；
任务队列主要作用，１、保证任务不会丢失，２、保证任务状态不会错乱；３、任务失败能恢复任务。
任务调度需要保证原子性操作，任务队列写入数据库，任务就能保证不丢失，保证任务状态的正确切换是能保证任务正常的调度，所以关键是调度的关键是保证状态的正确切换。
任务的调度和任务的执行存在沟通交互，任务执行失败后，任务需要重新调度，
执行体可能知道任务失败，也可能执行体异常失败，让调度器认为任务一直在计算，任务不能重置恢复计算，所以处理过程超时，任务将重新调度，以应对执行体异常。
有一些连续的操作需要异步执行，执行过程都有可能失败，执行过程可能需要先锁定任务，操作状态切换需要双方确认，末确认的情况当作失败，状态一直末切换也当失败，需重新处理。


新建任务：把任务初始化push到任务队列
获取任务：检测任务是否未调度，或者执行处理已经超时，把任务锁定为调度状态，把任务调度给执行体，执行体确认接收任务后，任务状态切换为计算状态，记录开始时间和写入执行体超时值，任务调度次数。
取消任务：针对在任务队列中未调度的任务可以直接取消，已经调度出去的任务先标记取消，然后把取消命令传给执行体，由执行体返回执行结果

任务重试：对失败的任务，重置hold_time,不重置计算器，这样任务重新调度出去，多次失败后，计算器达到失败次数，任务不再重试。

任务重置：像新建任务一样，重置任务所有状态。

任务查询：查询任务队列长度和任务状态，

任务调度：通过调度器使用队列索引遍列任务，不限制hold time，根据计算步骤对应计算单元来调度任务，适用于实例有多执行单元，计算存在依赖关系，由调度器分派任务到计算单元的调度方式。

调度只是任务的启点，每个任务可以是一个计算，也可以是串行的多个计算，可以使用的执行体可以是单个也可以是多个，
计算控制和执行体对应，串行计算和单个计算一样由控制管理异常和中断工作，计算中断和取消都表示任务的结束。

任务可以是执行体自动获取，也可以由调度器派发，单一执行体或一个实例上的多个执行体，可以使用自动获取，而分布式多个实例最好使用调度器派发任务。
所以单一执行体计算控制和任务获取一起构成任务调度，分布式的任务计算，调度器和执行控制分离，调度器把任务计算的清单发给执行体，任务没有在预定时间内完成，任务就被分配到其它执行体重新执行计算。

分布式计算中，计算执行体也叫计算单元，可以不保存计算任务，允许计算任务失败和丢失，计算任务的恢复由调度器控制。
资源池可以接受计算单元加入，也允许计算单元退出，可以根据计算任务弹性伸缩资源池的计算单元。

计算控制需要能接收计算任务，并控制计算流程，返回计算结果和状态

单一实例中包含多执行单元，执行任务包括多个计算，而且计算之前存在依赖关系，不能通过taken获取任务，而是要先查询任务状态，然后决定把计算按排到不同的计算单元。

总结：分布式计算和单一实例的多线程计算，如果计算之间存在关联关系，由调度器分派任务计算，由计算单元自动获取任务只适用无关联的任务。
自动获取任务，保证任务正确抢占需要原子性进行获取任务操作，整个需要一个全局原子性操作控制。
任务调度由调度器控制任务的分发，不要原子性抢占操作，调度方式对计算单元的交互要求低，更方便部署和管理。


一、任务队列实现

任务队列的结构
{'meta':{'type':'queue', 'tag':'task','max':1024}，'body': []}

meta描述队列的属性，type数据结构应用类型，标签label或tag，当存在多个任务队列，需要通过标签加以区别，max是限制任务队列的长度，
body是队列的实体，任务存储的队列，整个为json的数组类型，每个任务是一个对象。

一个任务对像的数据如下：
{"id": unique-id, "create_time":time.time(), "taken_time":None, "hold_timeout":None, "taken_counter":0}


创建任务队列和重置任务队列。
create / reset

放置任务
set / put / push / retry重置

获取任务
get / taken / pull

查询任务
query / find /index
返回总任务数，已经调度的任务和未高度的任务

结束任务
clean / cancel / commit

create 由队列名称和限制长度创建任务队列，
push 放置任务都先要检测是否超过队列限制长度，如果任务已经存在，提示任务已经存在。
taken 随机获取未调度的任务，或者hold_timeout任务超时未处理完的任务。
retry 查找到任务并重置时间，让任务能重新taken。
cancel 未调度任务直接弹出队列，调度出去的任务，先标记删除，再执行删除操作。
clean 标识任务失败，强制从队列中删除任务，完成清理工作
commit 任务完成后主动标记任务成功，删除队列中的任务。
query 查询任务队列，不会改变任务的标记，如不会改变hold_timeout值 
pause 先标记暂停，中断计算，暂停任务，不删除队列中的任务。
resume 恢复暂停的任务，暂停的恢复只适用于控制和计算在同一实例的自动获取任务，不适合分布式调度任务，计算节点有时不可恢复。


从业务层面考虑任务可以暂停或取消，取消可以是标记任务取消，也可以把任务从队列删除，
如果暂停可以恢复，那么可以不要从队列删除任务，而只是标记任务，修改标记就可以重新调度任务。

任务队列支持抢占式任务和调度任务两种方式，可以根据实际部署情况自由选择实现控制模板。


任务队列结合redis实现
第一种自动随机抢占任务：
任务队列结构： {'meta':{'type':'queue', 'tag':'task','max':1024}，'body': []}
把数据结构信息和数据内容分离，也就是meta和body分离，meta由字段指向数据实例。

初始化任务队列消息体内容
HMSET meta type 'list' tag 'task' max 1024  alias 'task_queue' number 0
HINCRBY meta number 1

创建任务并添加到队例
HMSET task1000000001 create 1589086715 taken null timeout 2000 counter 0
LPUSH task_queue task1000000001

把控制消息直接加入到任务队列中
LPUSH task_queue "{\"id\": \"task1000000001\",\"create\":1589086715,\"taken\":None, \"timeout\":None, \"counter\":0}"

查询结果LINDEX task_queue 0

把hold_time和hold_timeout合并，hold当前时间加超时时间延后时间为timeout时间。


redis python sdk操作
pip3 install redis

from time import time
import redis
redis_conn = redis.Redis(host='127.0.0.1', port= 6379, password= '', db= 0)
添加任务
v = redis_conn.hmset('task_1000000002', {'id': 'task_1000000002', 'create':time(),'timeout':0, 'counter':0})

查询任务
keys = redis_conn.keys()
keys = redis_conn.keys('task*')

获取任务
delay=2000
v = redis_conn.hset('task_1000000001', 'timeout',time()+delay})
v = redis_conn.hincrby('task_1000000001', 'counter', 1)

重置任务
v = redis_conn.hset('task_1000000001', 'timeout',0)

暂停任务
v = redis_conn.hset('task_1000000001', 'status','pause')

恢复任务
v = redis_conn.hset('task_1000000001', 'status','')

取消任务
v = redis_conn.delete('task_1000000001')

